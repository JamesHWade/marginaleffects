---
output: github_document
title: "fastmargins: Fast Marginal Effects"
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# Proof of concept

This is just a proof of concept. Please do not use in serious applications.

# Installation

You can install the released version of fastmargins from Github:

```{r, eval=FALSE}
remotes::install_github("vincentarelbundock/fastmargins")
```

# Examples

## Logit regression with a multiplicative interaction term

Load the library, simulate data, and estimate a logistic regression model with interaction terms:

```{r}
library(fastmargins)

N <- 1000
dat <- data.frame(
    x2 = rnorm(N),
    x1 = rnorm(N),
    x3 = rnorm(N),
    x4 = rnorm(N),
    e = rnorm(N))
dat$y <- rbinom(N, 1, plogis(
    dat$x1 + dat$x2 + dat$x3 + dat$x4 + dat$x3 * dat$x4))

mod <- glm(y ~ x1 + x2 + x3 * x4, data = dat, family = binomial)

summary(mod)
```

Compute unit-level marginal effects and variances:

```{r}
res <- mfx(mod)
head(res)
```

The results are obtained using a slightly different numerical approximation strategy than the one used in `margins`, so they will differ a bit. However, they are essentially indistinguishable:

```{r}
library(margins)

mar <- margins(mod, unit_ses = TRUE) |> data.frame()

cor(mar$dydx_x1, res$dydx_x1)
cor(mar$SE_dydx_x1, res$se_dydx_x1)

cor(mar$dydx_x3, res$dydx_x3)
cor(mar$SE_dydx_x3, res$se_dydx_x3)
```

## Conditional marginal effects with `ggplot2`

```{r, echo = FALSE}
library(ggplot2)
theme_set(theme_minimal())
```

```{r}
library(tidyverse)

lm(mpg ~ hp * wt, data = mtcars) |>
    mfx() |> 
    mutate(conf.low = dydx_hp - se_dydx_hp * 1.96,
           conf.high = dydx_hp + se_dydx_hp * 1.96) |>
    ggplot(aes(x = wt, 
               y = dydx_hp, 
               ymin = conf.low, 
               ymax = conf.high)) +
    geom_ribbon(alpha = .1) +
    geom_line()
```

# Benchmarks

Here are a couple naive benchmarks to compare the speed of computation with the `fastmargins` and `margins` packages. Since unit-level standard errors can be expensive to compute, we run the benchmarks with and without standard errors.

## Marginal effects and standard errors (unit-level)

In this naive benchmark, computing marginal effects with their unit-level standard errors is over 300x faster.

```{r}
b1 = bench::mark(
    margins(mod, unit_ses = TRUE),
    mfx(mod, variance = vcov(mod)),
    check = FALSE,
    max_iterations = 3)
b1
```

## Marginal effects only

In this naive benchmark, computing marginal effects *without* their unit-level standard errors is over 40% faster.

```{r}
b2 = bench::mark(
    margins(mod, unit_ses = FALSE),
    mfx(mod, variance = NULL),
    check = FALSE,
    max_iterations = 3)
b2
```
