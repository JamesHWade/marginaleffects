---
title: "Parallel computation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Parallel computation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 9,
  fig.asp = .4,
  out.width = "100%",
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
```

Computing marginal effects for a large number of variables can take a long time. Parallel computation can speed things up a bit. `marginaleffects` can use the `future.apply` package to parallelize. All that users need to do is load the `future.apply` library and call the `plan()` function.

Sequential computation (default):

```{r, eval = FALSE}
library(marginaleffects)

# simulate data
dat <- data.frame(matrix(rnorm(1e6), ncol = 50))
dat$y <- sample(0:1, nrow(dat), replace = TRUE)
mod <- glm(y ~ ., family = binomial, data = dat)

# sequential
system.time({
    marginaleffects(mod)
})

 #   user  system elapsed
 # 69.751   1.740  70.947
```

Parallel computation:

```{r, eval = FALSE}
library(future.apply)
plan("multisession")

system.time({
    marginaleffects(mod)
})

  #  user  system elapsed
  # 4.767   0.894  34.307
```

Note that many expensive operations inside `marginaleffects` cannot be parallelized, so the speed gains are not directly proportional to the number of available cores.

