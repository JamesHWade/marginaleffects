---
title: "Performance and Parallel Computation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Performance and Parallel Computation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
# this vignette is in .Rbuildignore because lme4 is not available on old CRAN
# test machines.

knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 9,
  fig.asp = .4,
  out.width = "100%",
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
```

# What to do when `marginaleffects` is slow?

Some options:

1. Compute marginal effects and contrasts at the mean (or other representative value) instead of all observed rows of the original dataset: Use the `newdata` argument and the `datagrid()` function.
2. Compute marginal effects for a subset of variables, paying special attention to exclude factor variables which can be particularly costly to process: Use the `variables` argument.
3. Do not compute standard errors: Use the `vcov = FALSE` argument.
4. Parallel computation (see section below).

This simulation illustrates how computation time varies for a model with 25 regressors and 100,000 observations:

```{r, eval = FALSE}
library(marginaleffects)

# simulate data and fit a large model
N <- 1e5
dat <- data.frame(matrix(rnorm(N * 26), ncol = 26))
mod <- lm(X1 ~ ., dat)

results <- bench::mark(
    # marginal effects at the mean; no standard error
    marginaleffects(mod, vcov = FALSE, newdata = datagrid()),
    # marginal effects at the mean
    marginaleffects(mod, newdata = datagrid()),
    # 1 variable; no standard error
    marginaleffects(mod, vcov = FALSE, variables = "X3"),
    # 1 variable
    marginaleffects(mod, variables = "X3"),
    # 26 variables; no standard error
    marginaleffects(mod, vcov = FALSE),
    # 26 variables
    marginaleffects(mod),
    iterations = 1, check = FALSE)

results[, c(1, 3, 5)]
#   expression                                                 median mem_alloc
# 1 marginaleffects(mod, vcov = FALSE, newdata = datagrid()) 200.18ms  181.79MB
# 2 marginaleffects(mod, newdata = datagrid())                  3.02s  228.77MB
# 3 marginaleffects(mod, vcov = FALSE, variables = "X3")     113.41ms  223.88MB
# 4 marginaleffects(mod, variables = "X3")                       2.4s    3.15GB
# 5 marginaleffects(mod, vcov = FALSE)                          2.05s    3.78GB
# 6 marginaleffects(mod)                                       56.31s   77.03GB
```

# Speed comparison

The `marginaleffects` functions are relatively fast. This simulation was conducted using the development version of the package on 2022-04-04:

```{r, eval = FALSE}
library(margins)

N <- 1e3
dat <- data.frame(
    y = sample(0:1, N, replace = TRUE),
    x1 = rnorm(N),
    x2 = rnorm(N),
    x3 = rnorm(N),
    x4 = factor(sample(letters[1:5], N, replace = TRUE)))
mod <- glm(y ~ x1 + x2 + x3 + x4, data = dat, family = binomial)
```

`marginaleffects` is 2.6x faster than `margins` when unit-level standard errors are *not* computed:

```{r, eval = FALSE}
bench::mark(
    marginaleffects(mod, vcov = FALSE),
    margins(mod, unit_ses = FALSE),
    check = FALSE, relative = TRUE, iterations = 1)

#   expression                           median 
# 1 marginaleffects(mod, vcov = FALSE)   1     
# 2 margins(mod, unit_ses = FALSE)       2.62  
```

`marginaleffects` is 65 times faster than `margins` when unit-level standard errors are computed:

```{r, eval = FALSE}
bench::mark(
    marginaleffects(mod, vcov = TRUE),
    margins(mod, unit_ses = TRUE),
    check = FALSE, relative = TRUE, iterations = 1)

#   expression                         median 
# 1 marginaleffects(mod, vcov = TRUE)  1
# 2 margins(mod, unit_ses = TRUE)      65.1
```

Models estimated on larger datasets (> 1000 observations) can be difficult to process using the `margins` package, because of memory and time constraints. In contrast, `marginaleffects` can work well on much larger datasets.

In some cases, `marginaleffects` will be considerably slower than packages like `emmeans` or `modmarg`. This is because these packages make extensive use of hard-coded analytical derivatives, or reimplement their own fast prediction functions.

# Parallel computation

Some -- but not all -- of the computations in `marginaleffects` can be parallelized. This can *sometimes* be useful when a model includes many variables, or when the marginal effects for each variable take a long time to compute.

### Use-case 1: Factor variables

Models which include several factor variables can take a while to process because the `marginaleffects()` or `comparisons()` functions need to compute all the pairwise contrasts. By loading the `future.apply` package and calling the `plan` function, we can instruct `marginaleffects` to treat each variable in parallel.

Sequential computing:

```{r, eval = FALSE}
library(marginaleffects)

N <- 1e3
dat <- data.frame(
    y = sample(0:1, N, replace = TRUE),
    x1 = factor(sample(letters[1:10], N, replace = TRUE)),
    x2 = factor(sample(letters[1:10], N, replace = TRUE)),
    x3 = factor(sample(letters[1:10], N, replace = TRUE)))
mod <- glm(y ~ x1 + x2 + x3, data = dat, family = binomial)

system.time({
    marginaleffects(mod)
})

#   user  system elapsed
# 27.381   0.071  22.316
```

Parallel computing is twice as fast:

```{r, eval = FALSE}
library(future.apply)
plan("multisession")

system.time({
    marginaleffects(mod)
})

#  user  system elapsed
# 0.564   0.001  10.991
```

Restore sequential computing:

```{r, eval = FALSE}
plan("sequential")
```

### Use-case 2: Many variables

All that users need to do is load the `future.apply` library and call the `plan()` function.

Sequential computation (default):

```{r, eval = FALSE}
dat <- data.frame(matrix(rnorm(1e6), ncol = 50))
dat$y <- sample(0:1, nrow(dat), replace = TRUE)
mod <- glm(y ~ ., family = binomial, data = dat)

# sequential
system.time({
    marginaleffects(mod)
})

#   user  system elapsed
# 69.751   1.740  70.947
```

Parallel computation:

```{r, eval = FALSE}
library(future.apply)
plan("multisession")

system.time({
    marginaleffects(mod)
})

#  user  system elapsed
# 4.767   0.894  34.307
```

# `data.table`

When the `data.table` package is installed locally in the user's `R` library, `marginaleffects` will automatically use that package to speed up bind and merge operations. This can result in significant speed-ups.
